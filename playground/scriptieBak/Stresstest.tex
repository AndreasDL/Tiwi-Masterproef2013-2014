\chapter{Loadtest}
{\samenvatting Deze masterproef maakt een monitoringsservice met een bijhorende monitoringsAPI die de monitoringsinformatie beschikbaar stelt. Dit systeem zal testbeds monitoren om zo de betrouwbaarheid van een testbed weer te geven. NAast betrouwbaarheid is echter ook de performantie van belang. Door een aantal aanpassingen aan de monitoringsservice werd tijdens de uitwerking van de masterproef ook een tool gemaakt die loadtesten kan uitvoeren. Een loadtest is een test waarbij een bestaande testen binnen een kort tijdsinterval meerdere malen uitgevoerd wordt. De loadtest zal eerst een bestaande test ophalen en deze vervolgens op meerdere threads tegelijk starten. Het is mogelijk om een wachttijd op te geven die gebruikt wordt tussen de verschillende testen. Zo is het bijvoorbeeld mogelijk om een wachttijd van 2 seconden op te geven. Hierbij wordt er tussen het opstarten van elke test 2 seconden gewacht.}
\section{Doel}
\npar
Het doel van een load test is kijken wat een testbed kan afhandelen. Een bestaande situatie waar dit nodig is, is wanneer een leerkracht met een groep studenten het testbed wil gebruiken om tcp-congestie te testen. Hierbij zouden 50 studenten elk 2 computers gebruiken om tcp-congestie te testen. TCP-congestie wordt gebruikt om fileproblemen die ontstaan door het overlopen van buffers te verhelpen. Deze problemen ontstaan nadat een host meer informatie doorstuurt dan een tussenliggende router kan afhandelen. Hierdoor zal de buffer van de router overlopen, wat leidt tot verlies van pakketten. Aangezien het TCP protocol garandeert dat een overdracht zeker en compleet is, worden deze pakketten opnieuw verzonden. Als men echter de verstuur snelheid niet verlaagd, zal dit alleen maar leiden tot meer verloren pakketten.
\clearpage
\npar
Om te kijken of het testbed 50 studenten met elk 2 nodes kan afhandelen, wordt een stresstest uitgevoerd. Deze stresstest wordt als voorbeeld uitgewerkt in bijlage A. De bedoeling van deze stresstest is om 50 login testen tegelijkertijd uit te voeren. Deze zullen een belasting veroorzaken op het testbed die vervolgend geanalyseerd kan worden. Uit een loadtest kan dus bepaald worden of de groep van 50 studenten tegelijkertijd een labo kan uitvoeren of de groep beter opgedeeld wordt in kleinere groepen.
\section{Uitwerking}
\npar
De uitwerking wordt weergegeven in Figuur \ref{structLoadtest}, let op de overeenkomsten met Figuur \ref{structService}, waar de monitoringsservice wordt uitgelegd. De uitwerking van de loadtest is op een aantal stappen na, gelijk aan de uitwerking van de monitoringsservice. 
\npar
Figuur \ref{structLoadtest} op volgende pagina geeft de uitwerking weer. Eerst wordt de bestaande test opgehaald. Vervolgens wordt een threadpool aangemaakt met de grootte n; het aantal testen dat uitgevoerd moet worden. Hierdoor kunnen alle testen tegelijkertijd uitgevoerd worden. Dit is niet mogelijk bij de service, vermits de grootte van de threadpool daar beperkt is. Vervolgens wordt elke test opgestart na een instelbaar interval. Dit interval wordt bijvoorbeeld gebruikt om te zorgen dat de testen elkaar om de 2 seconden opvolgen.
\npar
Eenmaal een test is opgestart en uitgevoerd, wordt elk resultaat geparset en doorgegeven aan de resultuploader. Deze zal de resultaten een voor een uploaden en daarbij de uitvoeringstijd van de volgende test niet aanpassen. Dat laatste zou ertoe leiden dat volgende resultaten niet meer aanvaard worden.
\npar
Na het uitvoeren van de testen zijn de resultaten van de stresstest opvraagbaar via de monitoringsAPI. Doordat er in de huidige implementatie geen onderscheid wordt gemaakt tussen resultaten van de monitoringsservice en de loadtester wordt deze databank en API gekloond. De kloon hiervan zal vervolgens dienen om de resultaten op te slaan. Samenvoegen van de monitoringresultaten met de loadtest resultaten is mogelijk, maar bleek niet noodzakelijk te zijn.

\mijnfiguur{width=1\textwidth}{structLoadtest}{De uitwerking van de loadtesten.}
