\chapter{Loadtest}
{\samenvatting Deze masterproef maakt een monitoringsservice met een bijhorende monitoringsAPI. Dit systeem zal testbeds monitoren en deze data toegankelijk maken om de betrouwbaarheid van een testbed te bepalen. Naast betrouwbaarheid is echter ook de performantie van belang. Door een aantal aanpassingen aan de monitoringsservice werd tijdens de uitwerking van de masterproef ook een tool gemaakt die loadtesten kan uitvoeren. Een loadtest is een test waarbij een bestaande testen binnen een kort tijdsinterval meerdere malen uitgevoerd wordt. De loadtest zal eerst een bestaande test ophalen en deze vervolgens op meerdere threads tegelijk starten.}
\section{Doel}
\npar
Een loadtest wordt gebruikt om te kijken welke belasting een testbed kan afhandelen. Een voorbeeld van een situatie waar dit nodig is, is wanneer een leerkracht met een groep studenten het testbed wil gebruiken voor een labo. Hierbij zouden 50 studenten elk 2 computers gebruiken om tcp-congestie te testen. TCP-congestie wordt gebruikt om fileproblemen die ontstaan door het overlopen van buffers te verhelpen. Deze problemen ontstaan nadat een host meer informatie doorstuurt dan een tussenliggende router kan afhandelen. Hierdoor zal de buffer van de router overlopen, wat leidt tot verlies van pakketten. Aangezien het TCP protocol garandeert dat een overdracht zeker en compleet is, worden deze pakketten opnieuw verzonden. Als men echter de verstuur snelheid niet verlaagd, zal dit alleen maar leiden tot meer verloren pakketten.
\clearpage
\npar
Het probleem is dat de leerkracht geen garantie heeft dat het testbed dit aankan. Hierdoor zijn vele leerkrachten weerhoudend om testbeds te gebruiken voor labo's.
Om aan te tonen dat het testbed wel een belasting van 50 studenten met elk 2 nodes aankan, wordt een stresstest uitgevoerd. Een voorbeeld van een uitgevoerde stresstest is terug te vinden in bijlage A. De bedoeling van deze stresstest is om 50 login testen tegelijkertijd uit te voeren. Deze zullen een belasting veroorzaken op het testbed die opgemeten en geanalyseerd wordt. Op basis van de resultaten kan een leerkracht met een gerust hart gebruik maken van het testbed of net aangeraden worden om de groep op te delen.
\section{Uitwerking}
\npar
De uitwerking wordt weergegeven in Figuur \ref{structLoadtest}, let op de overeenkomsten met Figuur \ref{structService}, waar de monitoringsservice wordt uitgelegd. De uitwerking van de loadtest is op een aantal stappen na, gelijk aan de uitwerking van de monitoringsservice, vermits de kern van beide gelijk is. 
\npar
Figuur \ref{structLoadtest} op volgende pagina geeft de uitwerking weer. Eerst wordt de bestaande test opgehaald. Daarna wordt een threadpool aangemaakt met de grootte n; het aantal testen dat uitgevoerd moet worden. Hierdoor kunnen alle testen tegelijkertijd uitgevoerd worden wat niet mogelijk is bij de service, vermits de grootte daar beperkt is. Vervolgens wordt elke test opgestart na een instelbaar interval. Dit interval zorgt er bijvoorbeeld voor dat de testen elkaar om de 2 seconden opvolgen.
\npar
Eenmaal een test is opgestart en uitgevoerd, wordt elk resultaat geparset en doorgegeven aan de resultuploader. Deze zal de resultaten een voor een uploaden en daarbij de uitvoeringstijd van de volgende test niet aanpassen. Dat laatste zou ertoe leiden dat volgende resultaten niet meer aanvaard worden. Merk het verschil met de monitoringsservice die hier wel een aanpassing doet van het nextrun veld, zie ook bijlage B.
\npar
Na het uitvoeren van de testen zijn de resultaten van de stresstest beschikbaar via de monitoringsAPI. Doordat er in de huidige implementatie geen onderscheid wordt gemaakt tussen resultaten van de monitoringsservice en de loadtesten wordt deze databank en API gekloond. De kloon hiervan zal vervolgens dienen om de resultaten van de loadtesten op te slaan. Samenvoegen van de monitoringresultaten met de loadtest resultaten is mogelijk, maar bleek noch een prioriteit, noch noodzakelijk te zijn.
\mijnfiguur{width=1\textwidth}{structLoadtest}{De uitwerking van de loadtesten.}