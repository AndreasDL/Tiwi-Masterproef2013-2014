\newpage
\chapter{Analyse en probleemstelling}
{\samenvatting
Zoals eerder besproken, zal deze masterproef een monitoringsAPI maken in opdracht van het onderzoekscentrum iMinds. De monitoringsAPI heeft als doel de resultaten van de achterliggende monitoringsservice aan te bieden. De monitorService zal op zijn beurt alle aggregaten (testfaciliteiten) binnen FIRE (Future Internet Research and Experimentation), een project voor de verbetering van onderzoek naar internet en netwerken, in de gaten houden. Dit hoofdstuk zal de werking van de FIRE monitor beschrijven. De FIRE monitor is de monitoringsservice die bij aanvang van de masterproef de monitoring verzorgde. Daarna zal er dieper ingegaan worden op de probleemstelling. Vervolgens wordt ook de GENI (Global Environment for Network Innovations) monitor kort besproken. GENI is een Amerikaans project met gelijkaardige doelstellingen als FIRE.}
\section{FIRE Monitor}
\npar
iMinds is het onderzoekscentrum waar de masterproef uitgewerkt wordt en is tevens leidinggevend in het FIRE project. iMinds heeft een monitoringsservice gemaakt die al enige tijd draait \citep{fed4fire-second-fed-arch}, de FIRE monitor. Deze monitoringsservice is ruimer dan de monitoring van testbeds, ook het monitoren van experimenten wordt door deze service afgehandeld\citep{fed4fire-second-fed-arch}. 
\subsection{Componenten}
\npar
De monitoringsservice bestaat uit verschillende componenten. De eerste component is de Facility monitoring. De monitoring wordt gebruikt bij de FLS (first level support). De first level support heeft als doel om de basiszaken van monitoring af te handelen. De voornaamste test is de pingtest die kijkt of een testbed nog online is. De aggregate bepaalt zelf welke testen er uitgevoerd worden.
\clearpage
\npar
De tweede component is de infrastucture monitoring. Deze component is gericht op componenten binnen een experiment. De verzamelde gegevens omvatten o.a. aantal verstuurde pakketten, aantal verloren pakketten, cpu-load, ... .
\npar
Een derde component is de OML measurement library, deze bibliotheek laat het toe dat een onderzoeker zijn eigen monitoring framework gebruikt om de metingen van zijn experiment te doen.
\npar
Deze masterproef richt zich op de Facility monitoring. De tweede en de derde component zijn hier minder relevant en worden verder buiten beschouwing gelaten. De monitoringsservice waarnaar verwezen wordt, is bijgevolg de Facility Monitoring.
\npar
De monitoringsservice (Facility Monitoring) is opgedeeld in een aantal stukken. Het eerste stuk is de FLS-monitor (First Level Support)\nomenclature{FLS}{First Level Support}. Deze heeft het doel actuele informatie weer te geven over de status van het testbed en is beschikbaar op https://flsmonitor.fed4fire.eu/,zie  Figuur \ref{monitoringview} .
\mijnfiguur{width=0.9\textwidth}{monitoringview}{FLS testbed monitoring}
\npar
Figuur \ref{monitoringview} geeft een beeld van de monitoringssite. De laatste 2 kolommen zijn van minder belang. De eerste kolom geeft de naam van het testbed weer. Daarnaast wordt het resultaat van de laatste ping test getoond. De volgend 2 kolommen bevatten het resultaat van respectievelijk de getVersiontest en de free resources test.GetVersion geeft aan of de AM (aggregate manager) nog werkt terwijl de kolom free resources aangeeft hoeveel resources er nog beschikbaar zijn. De vorm van deze testen is relatief eenvoudig aangezien er slechts een enkelvoudig resultaat wordt teruggegeven.

\clearpage
\npar
Het tweede deel van de monitoringsservice, nightly login testing, bevat complexere testen. Deze testen worden typisch 1 tot 2 keer per dag uitgevoerd. Deze testen zijn diepgaander dan de FLS-monitor. Een belangrijke test die hier gebeurt is de logintest. Hierbij wordt getest of het aanmelden op een testbed mogelijk is. Een andere test die uitgevoerd wordt, is de stitchingtest. Deze zal kijken of het mogelijk is om een netwerk op te zetten tussen verschillende testbeds. Zie Figuur \ref{monitoringStitch}
\mijnfiguur{width=0.94\textwidth}{monitoringStitch}{Resultaten van de stitching test}
Zoals zichtbaar in Figuur \ref{monitoringStitchHist}, is het ook mogelijk om de geschiedenis van deze testen op te vragen. 
\mijnfiguur{width=1\textwidth}{monitoringStitchHist}{Geschiedenis van resultaten}
\clearpage
\subsection{Testen}
\npar
De FLS monitor voert 3 soorten testen uit.
\begin{enumerate}
\item Een ping test die kijkt of een testbed nog online is. Dit is een eenvoudig ping commando dat regelmatig uitgevoerd wordt. 
\item Een getVersion call naar de AM (aggregate manager) API. Doordat de getVersion call geen authenticatie vereist, wordt deze test gebruikt om te testen of een AM nog werkt.
\item De listResources test, hiermee wordt gekeken hoeveel resources er nog beschikbaar zijn. Indien dit nul is, is het niet mogelijk om nieuwe testen te starten.
\end{enumerate}
\npar
Daarnaast zijn er nog een aantal test gedefinieerd. De belangrijkste zijn hier vermeld.
\begin{enumerate}
\item De login test, deze test zal proberen om aan te melden op een testbed.
\item Stitching test, deze test is redelijk complex. Vereenvoudigd zal een stitching test 2 verschillende testbeds met elkaar verbinden. Hiervoor wordt er ingelogd op beide testbeds en vervolgens wordt er op elk testbed een node gereserveerd. Dan worden deze nodes met elkaar verbonden en probeert men te pingen. 
\end{enumerate}
\clearpage
\subsection{Werking FLS monitor}
\npar
Figuur \ref{monitoringview2} geeft weer welke gegevens er opgevraagd worden. 
De eerste kolom geeft de naam van het testbed weer. De tweede kolom geeft de latency weer. De derde en vierde kolom komen overeen met de getVersion call en de listResources call. De 5e kolom houdt de interne status van het testbed bij, dit wordt door het testbed zelf ingevuld en doorgegeven. Ten slotte is er nog een timestamp die aangeeft wanneer de laatste update verlopen is. Indien een timestamp te oud wordt, duidt dat op problemen met de monitor die draait op het testbed.
\mijnfiguur{width=0.9\textwidth}{monitoringview2}{FLS testbed monitoring}
\npar
Figuur \ref{werkingFLS} op volgende pagina beschrijft de werking van de FLS monitor. Punt 1 stelt de pingtest voor. Hierbij wordt gekeken of de latency beneden een waarschuwingswaarde valt. De ping test verloopt rechtstreeks naar het testbed en niet via de AM. Punt 2 en 3 zijn de getVersion en listResources call naar de AM op het testbed. Al deze gegevens worden bijgehouden in een postgreSQL databank. Punt vier gaat over de interne status van het testbed. Dit wordt echter niet geïmplementeerd in de masterproef.
\npar
Rechtsboven is de webview weergeven, deze haalt de resultaten rechtstreeks uit de databank. Linksboven is de federator weergegeven. De federator is een component binnen een federatie. Deze component mag vrij ingevuld worden en wordt gebruikt binnen een federatie om het beheer vlotter te laten verlopen. Zo worden in dit voorbeeld de statistieken op lange termijn bijgehouden.
\mijnfiguur{width=0.9\textwidth}{werkingFLS}{Werking van de FLS monitor}
\npar
De FIRE monitor heeft een centrale database waarin de monitorinformatie zit. Deze database is de verbinding tussen de website en de resultaten van de test. Langs de ene kant wordt de uitvoer van de testen in de databank geüpdatet. Langs de andere kant worden deze gegevens opgevraagd door de website. Het is echter zo dat de FLS monitor zelf geen lange termijn statistieken bijhoudt. Dit komt doordat er bij het uitvoeren van testen geen nieuwe lijnen toegevoegd worden aan de databank. In plaats daarvan wordt de lijn geüpdatet.
\clearpage
\section{Probleemstelling}
\subsection{Bereikbaarheid}
\npar
Het voornaamste probleem is niet de structurering van de gegevens, maar de bereikbaarheid. In de vorige versie zijn de gegevens enkel bereikbaar via de webinterface, of rechtstreeks via de databank. Dit maakt het moeilijk voor nieuwe ontwikkelingen om deze gegevens te gebruiken. Deze masterproef lost dit probleem op door het gebruik van een montoringsAPI. Deze zorgt ervoor dat de gegevens vlot beschikbaar zijn via aanvragen aan de API.
\npar
Het ontwerpen van deze monitoringsAPI is het eerste deel van de masterproef. Deze API moet een vlotte toegang tot de resultaten garanderen. Ook moet het mogelijk zijn om deze resultaten de filteren. Een filter die er zeker noodzakelijk is, is het opvragen van de laatste resultaten van een testbed. Eenmaal deze API af is, kan alle communicatie met de achterliggende databank verlopen via de API. De websites die momenteel bestaan (zie Figuur \ref{monitoringview}), zullen nu niet meer rechtstreeks contact maken met de databank. In plaats daarvan zal de API gebruikt worden als datalaag.
\npar
Ook het toevoegen van nieuwe resultaten door de monitoringsservice verloopt via de API. Dit heeft als voordeel dat de API complexere zaken zoals foutafhandeling kan afhandelen. Een bijkomend voordeel is dat de databank niet extern bereikbaar moet zijn. Authenticatie kan in een hogere laag afgehandeld worden. Authenticatie zelf vormt geen onderdeel van de masterproef.
\npar
In een tweede deel moet ook gekeken worden naar bestaande monitoringssystemen. Zo heeft GENI (Global Environment for Network Innovations) eveneens een dergelijk framework. Integratie met dit framework zal de samenwerking tussen beide partijen bevorderen. De GENI monitor wordt later in dit hoofdstuk besproken.

\subsection{Structuur}
\npar
Naast de bereikbaarheid is er ook een structureel probleem. De testen van de FLS monitor hebben een eenvoudige structuur. De testen zijn eenvoudig omdat ze slechts een beperkt aantal parameters nodig hebben en een enkelvoudig resultaat teruggeven. Zo geeft een pingtest de ping waarde terug. Een listResources test geeft het aantal beschikbare resource terug. Beide waarden zijn gewoon getallen, die opgeslagen worden in een kolom van de databank.
\clearpage
\npar
De nightly login testen zijn echter complexer. Deze bestaan uit meerdere opeenvolgende stappen, elke stap heeft een tussenresultaat. Hierdoor volstaat een kolom niet meer. De oplossing die vroeger aangewend is, is het gebruiken van een tweede databank. In die databank is er niet voor elk tussenresultaat een kolom voorzien, maar heeft men de resultaten samen genomen in 2 tussen resultaten. Deze manier lost het probleem van het variabele aantal tussenresultaten op, maar geeft geen proper overzicht van alle tussen statussen. Voor deze informatie moet men zich wenden tot de log.
\section{GENI monitor}
\npar
Als er binnen FIRE een nieuw monitoringAPI gemaakt moet worden, is het nuttig om onderzoek te doen naar bestaande oplossingen hiervoor. Zo beschikt GENI over een monitoringsframework \citep{geni-monitor}, dat hieronder uitgelegd wordt.
\npar
GENI (Global Environment for Network Innovations) is een Amerikaans project dat, net zoals FIRE, een virtueel testlaboratorium heeft. Dit lab bestaat uit meerdere onderzoekscentra. Aangezien GENI en FIRE beide bezig zijn met onderzoek naar innovatieve netwerk- en internet ontwikkelingen, is de samenwerking tussen beide partijen vanzelfsprekend.
\mijnfiguur{width=0.9\textwidth}{geniDatastore}{Principe geni datastore}
\clearpage
\npar
Testbeds binnen GENI maken ook gebruik van een Slice federation architectuur. GENI heeft ook een monitoring framework ontwikkeld. Dit framework werkt met meerdere databronnen of datastores. Deze datastores hebben een REST polling API om informatie op te halen. Deze API wordt aangesproken door een collector. Een collector verzamelt de gegevens. Dit principe is geschetst in Figuur \ref{geniDatastore}
\mijnfiguur{width=0.9\textwidth}{geniCollector}{Een collector kan verschillende delen data ophalen.}
\npar
Een collector kan meerdere testbeds pollen. Hierbij moeten niet alle data opgehaald worden, het is mogelijk dat \'e\'en collector resultaten van een test op verschillende testbeds ophaald. Een collector zal de nodige gegevens ophalen om de aangesloten monitoringsapplicaties te laten werken. Normaal gezien zal een monitoringsapplicatie een collector gebruiken, al is dat geen vereiste. Dit is beschreven in Figuur \ref{geniCollector}. De boxen zijn de monitoringapplicaties. Deze hebben elk verschillende gegevens nodig, weergegeven in blauw. Elke monitoringsapplicatie heeft een collector (groen). De collector zal de nodige gegevens pollen van een datastore (oranje).
\npar
De intense samenwerking tussen FIRE en GENI maakt testbeds beschikbaar voor onderzoekers. Het is dan ook handig om de monitorAPI compatibel te maken met de GENI monitoringsservice. Daarvoor moet de monitoringAPI een datastore vormen. Concreet houdt dit in dat het antwoord van de resultaten aan een vastgelegde structuur moet voldoen. Omdat de huidige FIRE monitor veel meer informatie ter beschikking heeft dan de GENI datastore, zal deze masterproef kijken wat er ge\"integreerd kan worden en of er uitbreidingen nodig zijn aan de datastoreAPI. De GENI datastore API is nog in ontwikkeling.
\section{Besluit}
De vorige service werkte wel, maar was niet voorzien op de komst van complexere testen. Er zijn twee grote problemen, enerzijds de bereikbaarheid van de gegevens, anderzijds de structuur. Het eerste probleem is opgelost door het maken van een API. Het tweede probleem is opgelost door het uitbouwen van een complexe databank. Deze databank houdt zowel de resultaten als de configuratie van de testen bij. Ook is databank voorzien voor het opslaan van tussenresultaten. Als laatste onderdeel is er de integratie met GENI. Hierbij zal onderzocht worden wat er mogelijk is en waarvoor er nog uitbereidingen nodig zijn.