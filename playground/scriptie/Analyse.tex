\newpage
\chapter{Analyse en probleemstelling}
{\samenvatting
Zoals eerder besproken, zal deze masterproef een monitoringsAPI maken in opdracht van iMinds, een onderzoekscentrum. De monitoringsAPI heeft als doel de resultaten van de achterliggende monitoringsservice aan te bieden. De monitorService zal op zijn beurt alle aggregaten (testfaciliteiten) binnen FIRE (Future Internet Research and Experimentation), een project voor de verbetering van onderzoek naar internet en netwerken, in de gaten houden. Dit hoofdstuk zal de werking van de FIRE monitor beschrijven. De FIRE monitor is de monitoringsservice die bij aanvang van de masterproef de monitoring verzorgde. Daarna zal er dieper ingegaan worden op de probleemstelling. Vervolgens wordt ook de GENI (Global Environment for Network Innovations) monitor kort besproken. GENI is een Amerikaans project met gelijkaardige doelstellingen als FIRE.}
\section{FIRE Monitor}
\npar
iMinds (onderzoekscentrum waar de masterproef uitgewerkt wordt en tevens leidinggevend in het FIRE project), heeft een monitoringsservice gemaakt die al enige tijd draait \citep{fed4fire-second-fed-arch}, de FIRE monitor. Deze monitoringsservice is ruimer dan de monitoring van testbeds, ook het monitoren van experimenten wordt door deze service afgehandeld\citep{fed4fire-second-fed-arch}. 
\subsection{Componenten}
\npar
Deze monitoringsservice bestaat uit verschillende componenten. De eerste component is de Facility monitoring, deze monitoring wordt gebruikt bij de FLS (first level support). De first level support heeft als doel om de basis zaken van monitoring af te handelen. De voornaamste test is de pingtest die kijkt of een testbed nog online is. De aggregate bepaald zelf welke testen er uitgevoerd worden.
\clearpage
\npar
De tweede component is de infrastucture monitoring. Deze component is gericht om componenten binnen een experiment. De verzamelde data bevat o.a. aantal verstuurde pakketten, aantal verloren pakketten, cpu-load, ... .
\npar
Een derde component is de OML measurement library, deze bibliotheek laat het toe dat een onderzoeker zijn eigen monitoring framework gebruikt om de metingen van zijn experiment te doen.
\npar
Deze masterproef richt zich op de Facility monitoring. De tweede en de derde component zijn hier minder relevant en worden verder buiten beschouwing gelaten. De monitoringsservice waarnaar verwezen wordt, is bijgevolg de Facility Monitoring.
\npar
Deze monitoringsservice (Facility Monitoring) is opgedeeld in een aantal stukken. Het eerste stuk is de FLS-monitor (First Level Support)\nomenclature{FLS}{First Level Support}. Deze is beschikbaar op https://flsmonitor.fed4fire.eu/,zie ook Figuur \ref{monitoringview} . Deze service heeft het doel actuele informatie weer te geven over de status van het testbed.
\mijnfiguur{width=0.9\textwidth}{monitoringview}{FLS testbed monitoring}
\npar
Figuur \ref{monitoringview} geeft een beeld van de monitoringssite. De laatste 2 kolommen zijn van minder belang. De eerste kolom geeft de naam van het testbed weer. Daarnaast wordt het resultaat van de laatste ping test getoond. De volgend 2 kolommen bevatten het resultaat van respectievelijk de getVersiontest en de free resources test.GetVersion geeft aan of de AM (aggregate manager) nog werkt terwijl de kolom free resources aangeeft hoeveel resources er nog beschikbaar zijn. De vorm van deze testen is relatief eenvoudig, een enkelvoudig resultaat wordt teruggegeven.

\clearpage
\npar
Het tweede deel van de monitoringsservice, nightly login testing, bevat complexere testen. Deze testen worden typisch 1 tot 2 keer per dag uitgevoerd. Deze testen zijn diepgaander dan de FLS-monitor. Een belangrijke test die hier gebeurd is de logintest. Hierbij wordt een getest of het aanmelden op een testbed mogelijk is. Een andere test die uitgevoerd wordt, is de stitchingtest. Deze zal kijken of het mogelijk is om een netwerk op te zetten tussen verschillende testbeds. Zie Figuur \ref{monitoringStitch}
\mijnfiguur{width=0.94\textwidth}{monitoringStitch}{resultaten van de stitching test}
Zoals zichtbaar in Figuur \ref{monitoringStitchHist}, is het ook mogelijk om de geschiedenis van deze testen op te vragen. 
\mijnfiguur{width=1\textwidth}{monitoringStitchHist}{geschiedenis van resultaten}
\clearpage
\subsection{testen}
\npar
De FLS monitor voert 3 soorten testen uit.
\begin{enumerate}
\item Een ping test die kijkt of een testbed nog online is. Dit is een eenvoudig ping commando dat regelmatig uitgevoerd wordt. 
\item Een getVersion call naar de AM (aggregate manager) API. Doordat de getVersion call geen authenticatie vereist, wordt deze test gebruikt om te testen of een AM nog werkt.
\item De listResources test, hiermee wordt gekeken hoeveel resources er nog beschikbaar zijn. Indien dit nul is, is het niet mogelijk om nieuwe testen te starten.
\end{enumerate}
\npar
Daarnaast zijn er nog een aantal test gedefinieerd. De belangrijkste zijn hier vermeld.
\begin{enumerate}
\item De login test, deze test zal proberen om aan te melden op een testbed.
\item Stitching test, deze test is redelijk complex. Vereenvoudigd zal een stitching test 2 verschillende testbeds met elkaar verbinden. Hiervoor wordt er ingelogd op beide testbeds en vervolgens wordt er op elk testbed een node gereserveerd. Dan worden deze nodes met elkaar verbonden en probeert men te pingen. 
\end{enumerate}
\clearpage
\subsection{Werking FLS monitor}
\npar
Figuur \ref{monitoringview2} geeft weer welke data er opgevraagd wordt. 
De eerste kolom is geeft de naam van het testbed weer. De tweede kolom geeft de latency weer. De derde en vierde kolom komen overeen met de getVersion call en de listResources call. De 5e kolom houdt de interne status van het testbed bij, dit wordt door het testbed zelf ingevuld en doorgegeven. Ten slotte is er nog een timestamp die aangeeft wanneer de laatste update verlopen is. Indien een timestamp te oud wordt, duidt dat op problemen met de monitor die draait op het testbed.
\mijnfiguur{width=0.9\textwidth}{monitoringview2}{FLS testbed monitoring}
\npar
Figuur \ref{werkingFLS} beschrijft de werking van de FLS monitor. Punt 1 stelt de pingtest voor. Hierbij wordt gekeken of de latency beneden een waarschuwingswaarde valt. De ping test verloopt rechtstreeks naar het testbed en niet via de AM. Punt 2 en 3 zijn de getVersion en listResources call naar de AM op het testbed. Als deze data wordt bijgehouden in een postgreSQL databank. Punt vier gaat over de interne status van het testbed. Dit wordt echter niet geïmplementeerd in de masterproef.
Rechtsboven is de webview weergeven, deze haalt de resultaten rechtstreeks uit de databank. Linksboven is de federator weergegeven. De federator is een component binnen een federatie. Deze component mag vrij ingevuld worden en wordt gebruikt binnen een federatie om het beheer vlotter te laten verlopen. Zo wordt in dit voorbeeld de statistieken op lange termijn bijgehouden.
\mijnfiguur{width=0.9\textwidth}{werkingFLS}{Werking van de FLS monitor}
\npar
De FIRE monitor heeft dus een centrale database waarin de monitor informatie zit. Deze database is de verbinding tussen de website en de resultaten van de test. Langs de ene kant wordt de uitvoer van de testen in de databank geüpdatet. Langs de andere kant wordt deze data opgevraagd door de website. Het is echter zo dat de FLS monitor zelf geen lange termijn statistieken bijhoudt. Dit komt doordat er bij het uitvoeren van testen geen nieuwe lijnen toegevoegd worden aan de databank. In plaats daarvan wordt de lijn geüpdatet.
\clearpage
\section{Probleemstelling}
\subsection{Bereikbaarheid}
\npar
Het voornaamste probleem is niet de structurering van de data, maar de bereikbaarheid. In de vorige versie is de data enkel bereikbaar via de webinterface, of rechtstreeks via de databank. Dit maakt het moeilijk voor nieuwe ontwikkelingen om deze data te gebruiken. Deze masterproef lost dit probleem op door het gebruik van een montoringsAPI. Deze zorgt ervoor dat de data vlot beschikbaar is via aanvragen aan de API.
\npar
Het ontwerpen van deze monitoringsAPI is het eerste deel van de masterproef. Deze API moet een vlotte toegang tot de resultaten garanderen. Ook moet het mogelijk zijn om deze resultaten de filteren. Een filter die er zeker noodzakelijk is, is het opvragen van de laatste resultaten van een testbed. Eenmaal deze api af is, kan alle communicatie met de achterliggende databank verlopen via de API. De website's die momenteel bestaat (zie Figuur \ref{monitoringView}), zal nu niet meer rechtstreeks contact maken met de databank. In plaats daarvan zal de API gebruikt worden als datalaag.
\npar
Ook toevoegen van nieuwe resultaten, door de monitoringsservice verloopt via de API. Dit heeft als voordeel dat de API complexere zaken zoals foutafhandeling kan afhandelen. Een bijkomend voordeel is dat de databank niet extern bereikbaar moet zijn. Authenticatie kan in een hogere laag afgehandeld worden. Merk op dat authenticatie geen onderdeel is van deze masterproef.
\npar
Daarnaast moet ook gekeken worden naar bestaande monitoringssystemen. Zo heeft GENI (Global Environment for Network Innovations) een dergelijk framework. Integratie met dit framework zal de samenwerking tussen beide partijen bevorderen. De GENI monitor wordt later in dit hoofdstuk besproken.

\subsection{Structuur}
\npar
Naast de bereikbaarheid is er ook een structureel probleem. De testen van de FLS monitor hebben een eenvoudige structuur. De testen zijn eenvoudig omdat ze slechts een beperkt aantal parameters nodig hebben en een enkelvoudig resultaat teruggeven. Zo geeft een pingtest de ping waarde terug. Een listResources test geeft het aantal beschikbare resource terug. Beide waarden zijn gewoon getallen, die opgeslagen worden in een kolom van de databank.
\clearpage
\npar
De nightly login testen zijn echter complexer. Deze bestaan uit meerdere opeenvolgende stappen, elke stap heeft een tussenresultaat. Hierdoor volstaat een kolom niet meer. De oplossing die toen aangewend is, is het gebruiken van een tweede databank. In die databank is er niet voor elk tussenresultaat een kolom voorzien, maar heeft men de resultaten samen genomen in 2 tussen resultaten. Deze manier lost het probleem van het variabele aantal tussenresultaten op, maar geeft geen proper overzicht van alle tussen statussen. Voor deze informatie moet men zich wenden tot de log.
\section{GENI monitor}
\npar
Als er binnen FIRE een nieuw monitoringAPI gemaakt moet worden, is het nuttig om onderzoek te doen naar bestaande oplossingen hiervoor. Zo beschikt GENI over een monitoringsframework \citep{geni-monitor}, dat hieronder uitgelegd wordt.
\npar
GENI (Global Environment for Network Innovations) is een amerikaans project dat , net zoals FIRE, een virtueel testlaboratorium heeft. Dit lab is gedeeld over meerdere onderzoekscentra. Aangezien GENI en FIRE beide bezig zijn met onderzoek naar innovatieve netwerk en internet ontwikkelingen, is de samenwerking tussen beide partijen vanzelfsprekend.
\npar
Testbeds binnen GENI maken ook gebruik van een Slice federation architectuur. GENI heeft ook een monitoring framework ontwikkeld. Dit framework werkt met meerdere databronnen, datastores. Deze datastores hebben een REST polling API om informatie op te halen. Deze API wordt aangesproken door een collector. Een collector verzameld de data. Dit principe is geschetst in Figuur \ref{geniDatastore}
\npar
Een collector kan meerdere testbeds pollen. Hiermoet moet niet alle data opgehaald worden, het is mogelijk dat een collector resultaten van een test op verschillende testbeds ophaald. Een collector zal welke data dan ook nodig is ophalen om de aangesloten monitoring applicaties te laten werken. Normaal gezien zal een monitorings applicatie een collector gebruiken, al is dat geen vereiste. Dit is beschreven in Figuur \ref{geniCollector}. De boxen zijn de monitoringapplicaties. Deze hebben elk verschillende data nodig, weergegeven in blauw. Elke monitoringapplicatie heeft een collector (groen). De collector zal de nodige data pollen van een datastore (oranje).
\mijnfiguur{width=0.9\textwidth}{geniDatastore}{Principe geni datastore}
\mijnfiguur{width=0.9\textwidth}{geniCollector}{Een collector kan verschillende delen data ophalen.}
\clearpage
\npar
Door de intense samenwerking tussen FIRE en GENI waarbij testbeds beschikbaar gemaakt worden voor onderzoekers, is het zeker handig om de monitorAPI compatibel te maken hiermee. Daarvoor moet de monitoringAPI een datastore vormen. Doordat de huidige FIRE monitor veel meer informatie ter beschikking heeft dan de datatore, zal deze masterproef kijken wat er geïntegreerd kan worden en of er uitbereidingen nodig zijn aan de datastoreAPI. Merk op dat het GENI datastore API nog in ontwikkeling is.
\section{Besluit}
De vorige service werkte wel, maar was niet voorzien op de komst van complexere testen. Er zijn 2 grote problemen, enerzijds de bereikbaarheid van de data, anderzijds de structuur. Het eerste probleem is opgelost door het maken van een API. Het tweede probleem is opgelost door het uitbouwen van een complexe databank. Deze databank houdt zowel de resultaten als de configuratie van de testen bij. Ook is databank voorzien voor het opslaan van tussenresultaten. Als laatste onderdeel is er de integratie met GENI. Hierbij zal onderzocht worden wat er mogelijk is en waarvoor er nog uitbereidingen nodig zijn.