\chapter{Onderhoud, beheer en gebruik}
{\samenvatting Dit hoofdstuk richt zich tot de systeem beheerder en bespreekt hoe het onderhoud van de de monitoringsAPI en service verloopt. Hierbij wordt de nadruk gelegd op het toevoegen, verwijderen, activeren en deactiveren van testen.}
\npar
\section{Over}
\npar
Een testinstantie maakt de link tussen een testdefinitie en zijn set parameters. In volgende tekst wordt, tenzij anders vermeld, met test ook altijd een testinstantie bedoeld. Een test heeft altijd een type, dit type wordt gedefinieerd door de testdefinition die ook opgeslagen zit in de databank. De bedoeling is dat een systeembeheerder eenvoudig nieuwe testtypes kan ondersteunen door nieuwe definities aan te maken. Dit kan op meerdere manier en is hieronder beschreven.
\npar
Daarnaast heeft een test ook een nextrun veld, dit veld bevat een iso 8601 timestamp met tijdzone en geeft aan wanneer de test de volgende keer uitgevoerd moet worden. De test zal uitgevoerd worden op het moment dat de monitoringsservice (die periodiek opgestart wordt via cron) de API pollt naar testen die uitgevoerd moeten worden. Als nextrun dan in het verleden ligt, zal de test doorgestuurd worden en uitgevoerd worden. De nextrun zal aangepast worden door de monitoringsservice als volgt: $nextrun_{new} = starttime + frequency$.
\npar
Het is ook mogelijk om testen te deactiveren door het veld enabled op false te zetten. Deze testen zullen bijgevolg niet uitgevoerd worden ongeacht de waarde van hun nextrun veld. Vanzelfsprekend moet dit veld terug op true gezet worden om de test terug te activeren.

\section{Toevoegen van testen (testinstancies)}
\npar
Voor het toevoegen van een testinstanties moet er eerst gekeken worden naar het de bijhorende definitie. De definitie kan opgevraagd worden via /testdefinition?testdefinitionname=$<$definitienaam$>$ (zie ook bijlage B). Vervolgens moeten alle parameters ingesteld worden. 
\npar 
Een voorbeeld, de definitie van een list resource test is:
\begin{lt}
    "listResources": {
        "testdefinitionname": "listResources",
        "testtype": "listResources",
        "testcommand": "",
        "parameters": {
            "user": {
                "type": "user",
                "description": "user for authentication"
            },"testbed": {
                "type": "testbed",
                "description": "testbed to get the list recources from"
            },"context-file": {
                "type": "file",
                "description": "username = \n    passwordFilename = \n    pemKeyAndCertFilename = \n    userAuthorityUrn = "
            }
        },"returnValues": {
            "count": {
                "type": "int",
                "description": "free resources"
            },"rspec": {
                "type": "file",
                "description": "path of rspec file"
            }
        }
    }
\end{lt}
\npar 
Hier kan uit afgeleid worden dat een listResource test een user, testbed en context file nodig heeft om een count en rspec terug te geven. Parameters worden dan bijvoorbeeld met een python script ingevuld, zoals in het voorbeeld hieronder waarbij een listResources test voor wall2 gemaakt wordt.
\clearpage
\begin{lstlisting}[language=Python]
import psycopg2 #deze bibliotheek verzorgt toegang tot postgresql databanken vanuit python

#queries eerste geeft de testinstance id terug, die dan gebruikt wordt om de parameters toe te voegen.
addTestQ = "INSERT INTO testinstances (testname,testDefinitionName,frequency,nextrun,enabled) VALUES(\%s,\%s,\%s,\%s,\%s) RETURNING testinstanceid"
addParQ  = "INSERT INTO parameterInstances (testinstanceId,parameterName,parametervalue) VALUES (\%s,\%s,\%s)"

#connectie maken
con = psycopg2.connect(database=dbname,user=user,password=pass,host=durl) 
#vul overeenkomstige waarden in
cur = con.cursor()

#maak test
cur.execute(addTestQ,("wall2list,"listResources",3600,2014-6-1T12:00:00,true))
testinstanceid = cur.fetchone()[0] #ophalen id

#parameters
cur.execute(addParQ,(testinstanceid,"testbed",wall2))	
cur.execute(addParQ,(testinstanceid,"user",ftester))

#commit
con.commit()

\end{lstlisting}
\npar
Hiervoor moet het testbed wall2 en de user ftester bestaan.

\section{Toevoegen van types/definities (testdefinitions)}
\npar
Definities kunnen op meerdere manieren toegevoegd worden.
\begin{enumerate}
\item nieuw intern type
\item testdefinitie toevoegen in de databank.
\end{enumerate}

\subsection{Nieuw intern type}
Het is zo dat elke test een intern type heeft dit type komt overeen met een klasse in ... . In deze klasse kunnen parameters hardgecodeerd worden, bijgevolg moeten ze niet meer opgeslagen worden in de databank en doorgegeven worden. Op deze manier is het mogelijk om bijvoorbeeld een eenvoudige stitching test te maken met een aantal standaard waarden. Naast deze test zou er nog een advanced stitching test kunnen zijn waar de parameters wel opgegeven moeten worden. Beide testen zouden vervolgens verschillend in naam. Bijgevolg kan men eenvoudig kiezen tussen beide varianten door het overeenkomstige testtype te kiezen.
%voorbeelden van stitching klasse.
%voorbeeld voor ping (bash commando)

\subsection{Testdefinitie toevoegen in de databank}
\npar
Een tweede manier is het toevoegen van een definitie in de databank, deze test heeft dan als intern type ofwel bash ... ofwel automated tester ... . Bij de eerste wordt de commando tekst beschouwd als het commando, bij de tweede zijn dit de parameters die meegegeven worden aan de automated tester. Waarden van parameters kunnen opgevraagd worden door de parameter naam tussen $<$ en $>$ te plaatsen.
%voorbeeld script

\section{Troubleshooting}
\subsection{Resultaten worden niet opgeslagen door de API}
\npar
Resultaten kunnen om een van volgende redenen geweigerd worden:
\begin{enumerate}
\item het testid bestaat niet of is onjuist
\item Niet alle tussenresultaten die in de testdefinitie gedefinieerd zijn, zijn meegegeven. 
\item nextrun ligt niet na de bestaande nextrun, dit kan ontstaan door fouten met tijdzones. Normaal gezien wordt een unix timestamp gebruikt in microseconden (1/1000 000 seconde).
\end{enumerate}
De regel is ook dat ofwel alles wordt opgeslagen ofwel niets. Er wordt gebruikt gemaakt van transacties die de integriteit van de data bewaren.
\subsection{Het programma loopt vast tijdens het uitvoeren van een zelf aangemaakte testen.}
\npar 
Controleer of alle parameternamen, opgegeven in de instance, overeenkomen met de namen van de parameters in de definitie.

\section{Uitbereidingen}
\begin{enumerate}
\item cron lijnen voor scheduling ipv nextrun en frequency
\item default waarden voor parameters
\item samenvoegen loadtest en service
\end{enumerate}