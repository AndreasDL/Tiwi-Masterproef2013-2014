\chapter{Ontwerp monitor}
{\samenvatting De masterproef maakt een monitoringssysteem bestaande uit een monitoringsservice en een monitoringsAPI die deze data beschikbaar stelt. De masterproef bestaat uit verschillende projecten. De kern van deze projecten is de API, de API bied monitor informatie aan en vormt tevens de verbinding tussen alle andere projecten. Om aan monitorinformatie te komen is een monitoringsservice ontworpen. Deze service zal aggregates controleren en de resultaten opslaan in de databank. Tenslotte is een website ontworpen om de informatie weer te geven.}
\section{Structuur}
\npar
De masterproef zal een monitor maken bestaande uit een aantal projecten. Volgende sectie bespreekt hun verband en waarvoor elk deel verantwoordelijk is.
\begin{enumerate}
\item Een databank die alle data bijhoudt.
\item Een monitoringsAPI die de kern vormt. Alle andere projecten zijn verbonden via de API.
\item Een monitoringsservice die de testen uitvoert.
\item Een loadtester om testbeds te belasten.
\item Een website om de monitoringsinfo weer te geven.
\end{enumerate}
Daarnaast zijn er nog 2 projecten weergegeven. Deze projecten zijn niet door deze masterproef ontwikkelt. Ze zijn vermeldt vanwege hun verband met de masterproef.
\begin{enumerate}
\item Geni monitoringframework, hiervoor wordt de interface van een datastore geïmplementeerd.
\item Later: andere aplicaties bv.jFed, ... Dit duidt erop dat de monitoringsAPI een basis is waarop andere applicaties kunnen verder bouwen. Zo is het mogelijk dat de monitoringsinformatie in de toekomst ge\"integreerd wordt in de primaire gebruikers interface van jFed.
\end{enumerate}
Figuur \ref{opbouw} geeft een schematische weergave van de verschillende delen van de masterproef die hierboven uitgelegd staan.
\mijnfiguur{width=0.9\textwidth}{opbouw}{De samenhang van de verschillende projecten in de masterproef.}
\npar
De volgende pagina's geven een korte omschrijving van wat elk deel moet kunnen. De werking en concrete implementatie komen in een later hoofdstuk aan bod. 
\section{De API}
\npar
Dit onderdeel vorm de kern die alle andere projecten aan elkaar bindt. De monitoringsAPI staat in voor de communicatie tussen de buitenwereld en de databank. Enerzijds worden er resultaten toegevoegd aan de databank. Deze resultaten zijn afkomstig van de monitoringsservice. Anderzijds worden er resultaten opgevraagd uit de databank door zowel de website als de GENI collector. De monitoringAPI is verantwoordelijk voor het beheer van de databank. Alle communicatie met de databank zal via de API verlopen. Dit heeft als voordeel dat zaken zoals foutafhandeling maar een keer ge\"implementeerd moeten worden. Voor de implementatie wordt PHP gebruikt in combinatie met een apache HTTP server.
\section{De databank}
\npar
De databank is verantwoordelijk voor het bijhouden van de informatie. Deze informatie kan opgedeeld worden als volgt:
\begin{enumerate}
\item Configuratie van testen:
\begin{enumerate}
\item De testbeds die door de monitoringsservice gecontroleerd moeten worden.
\item De logins die gebruikt worden voor authenticatie op de testbeds.
\item De beschikbare testen: hierbij moet het mogelijk zijn om nieuwe testen toe te voegen zonder te veel verandering aan te brengen in de code.
\item De planning van de testen, hierbij moet het mogelijk zijn om elke test met een verschillend interval uit te voeren. 
\end{enumerate}
\item Resultaten van testen: naast het bijhouden van de configuratie moeten ook resultaten van elke test bijgehouden worden.
\end{enumerate}
\npar
De databank zit verborgen achter de monitoringsAPI. Alle communicatie met de databank verloopt via de monitoringsAPI. De databank is een PostgreSQL databank.
\section{De monitoringsservice}
\npar
Dit deel voert de testen uit. Eerst zullen de testen die uitgevoerd moeten worden opgevraagd worden aan de API. Vervolgens worden deze testen simultaan uitgevoerd. Hierbij wordt gebruikt gemaakt van een threadpool. De monitoringsservice wordt in Java gemaakt.
\section{De loadtester}
\npar
Een loadtest wordt gebruikt om te kijken welke belasting een testbed kan afhandelen. Een voorbeeld van een situatie waar dit nodig is, is wanneer een docent met een groep studenten het testbed wil gebruiken voor een labo. Hierbij zouden 50 studenten elk 2 computers gebruiken om tcp-congestie te testen. TCP-congestie wordt gebruikt om fileproblemen die ontstaan door het overlopen van buffers te verhelpen. Deze problemen ontstaan nadat een host meer informatie doorstuurt dan een tussenliggende router kan afhandelen. Hierdoor zal de buffer van de router overlopen, wat leidt tot verlies van pakketten. Aangezien het TCP protocol garandeert dat een overdracht zeker en compleet is, worden deze pakketten opnieuw verzonden. Als men echter de frequentie waarmee de pakketten verstuurd worden niet verlaagt, zal dit alleen maar leiden tot meer verloren pakketten.
\npar
Het probleem is dat de docent geen garantie heeft dat het testbed dit aankan. Hierdoor zijn vele docenten weerhoudend om testbeds te gebruiken voor labo's.
Om aan te tonen dat het testbed wel een belasting van 50 studenten met elk 2 nodes aankan, wordt een stresstest uitgevoerd. De bedoeling van deze stresstest is om 50 logintesten tegelijkertijd uit te voeren. Deze zullen een belasting veroorzaken op het testbed die opgemeten en geanalyseerd wordt. Op basis van de resultaten kan de docent met een gerust hart gebruik maken van het testbed of net aangeraden worden om de groep op te delen. De loadtester zal een applicatie voorzien om het testbed te belasten.
\section{De website}
\npar
De layout van de vorige webservice is overgenomen, maar een aantal punten zijn aangepast. De nieuwe website geeft wel alle tussenresultaten weer in het overzicht. Voorts is ook de backend van de site vervangen door een aantal API-calls. 
\npar
De bedoeling van deze website is een eenvoudig, maar duidelijk overzicht bieden. Hierbij moet een onderzoeker zeer snel de status van het testbed waarop hij werkt, kunnen raadplegen. Voor dit deel wordt gebruik gemaakt van javascript, html en PHP. Daarnaast wordt Apache gebruikt als HTTP server.
\section{Het GENI monitoringframework}
\npar
Het GENI monitoringsframework bestaat uit 2 delen. Het eerste deel is een datastore; dit is een locatie waar monitoringsinformatie beschikbaar is. Het tweede deel is een collector. Een collector wordt gebruikt door een applicatie om de monitoringsinformatie die hij nodig heeft op te halen van de datastores.
\npar 
Binnen het GENI project zijn er al mensen bezig met de beveiliging en weergaven van de monitoringsdata. Door de API compatibel te maken met de GENI monitor, kunnen deze ontwikkelingen in de toekomst eenvoudig overgenomen worden. Als laatste deel van de masterproef zal er gekeken worden welke integratie mogelijk is, en of er uitbreidingen nodig zijn aan de API's.
\clearpage
\section{Toekomstige ontwikkelingen}
\npar
Dit stuk geeft aan dat de monitoringsAPI verder gaat dan huidige toepassingen. Het is de bedoeling dat de monitoringsAPI de monitoringsinformatie toegankelijk maakt voor toekomstige ontwikkelingen. Een voorbeeld hiervan is de integratie van de monitoringsinformatie in jFed. Op deze manier zou een onderzoeker die met jFed werkt meteen kunnen zien welke testbeds betrouwbaar zijn. Vervolgens kan hij een betrouwbaar testbed gebruiken voor zijn testen op uit te voeren.